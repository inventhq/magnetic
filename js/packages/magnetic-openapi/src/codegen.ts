// codegen.ts — Generate TypeScript interfaces from parsed OpenAPI schemas

import type { ParsedApi, SchemaInfo, PropertyInfo, ApiEndpoint } from './types.ts';

/** Convert a schema name to a valid TypeScript identifier */
function safeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_');
}

/** Generate a TypeScript interface from a SchemaInfo */
function schemaToInterface(schema: SchemaInfo): string {
  const lines: string[] = [];

  if (schema.description) {
    lines.push(`/** ${schema.description} */`);
  }

  lines.push(`export interface ${safeName(schema.name)} {`);

  for (const prop of schema.properties) {
    const opt = prop.required ? '' : '?';
    const nullable = prop.nullable ? ' | null' : '';
    const desc = prop.description ? `  /** ${prop.description} */\n` : '';

    lines.push(`${desc}  ${prop.name}${opt}: ${prop.type}${nullable};`);
  }

  lines.push('}');
  return lines.join('\n');
}

/** Generate endpoint type comments for reference */
function endpointComment(ep: ApiEndpoint): string {
  const parts: string[] = [];
  parts.push(`// ${ep.method} ${ep.path}`);
  if (ep.summary) parts.push(`//   ${ep.summary}`);
  if (ep.requestBody) parts.push(`//   Request: ${ep.requestBody}`);
  if (ep.responseSchema) parts.push(`//   Response: ${ep.responseSchema}`);
  if (ep.requiresAuth) parts.push(`//   Auth: required`);
  if (ep.queryParams.length > 0) {
    const qs = ep.queryParams.map(q => `${q.name}${q.required ? '' : '?'}: ${q.type}`).join(', ');
    parts.push(`//   Query: { ${qs} }`);
  }
  return parts.join('\n');
}

/**
 * Generate TypeScript type definitions from a parsed API spec.
 *
 * Output is a standalone .ts file with:
 * - All schema interfaces
 * - Endpoint reference comments
 * - Data source type aliases for use in toViewModel()
 */
export function generateTypes(api: ParsedApi): string {
  const sections: string[] = [];

  // Header
  sections.push(`// Auto-generated types from ${api.title} v${api.version}`);
  sections.push(`// Source: ${api.baseUrl} (${api.specVersion})`);
  sections.push(`// Generated by @magneticjs/openapi\n`);

  // Schema interfaces
  if (api.schemas.length > 0) {
    sections.push('// ── Schemas ──────────────────────────────────────────────────────\n');
    for (const schema of api.schemas) {
      sections.push(schemaToInterface(schema));
      sections.push('');
    }
  }

  // Endpoint reference
  if (api.endpoints.length > 0) {
    sections.push('// ── Endpoints ────────────────────────────────────────────────────\n');
    for (const ep of api.endpoints) {
      sections.push(endpointComment(ep));
    }
    sections.push('');
  }

  // Data source helper types (for endpoints that return arrays — common for list pages)
  const listEndpoints = api.endpoints.filter(
    ep => ep.method === 'GET' && ep.responseSchema?.endsWith('[]')
  );
  if (listEndpoints.length > 0) {
    sections.push('// ── Data source types (for magnetic.json "data" keys) ────────────\n');
    for (const ep of listEndpoints) {
      const itemType = ep.responseSchema!.replace('[]', '');
      const name = ep.operationId || ep.path.replace(/[^a-zA-Z0-9]/g, '_').replace(/^_+|_+$/g, '');
      sections.push(`export type ${safeName(name)}Data = ${safeName(itemType)}[];`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Generate a suggested magnetic.json data sources config
 * based on discovered API endpoints.
 */
export function suggestDataSources(api: ParsedApi): Record<string, { url: string; page: string; auth: boolean }> {
  const sources: Record<string, { url: string; page: string; auth: boolean }> = {};

  // Only suggest GET endpoints (data sources are read-only)
  const getEndpoints = api.endpoints.filter(ep => ep.method === 'GET');

  for (const ep of getEndpoints) {
    // Skip endpoints with path params (need dynamic resolution)
    if (ep.pathParams.length > 0) continue;

    // Use operationId or path as key
    const key = ep.operationId
      || ep.path.replace(/^\//, '').replace(/\//g, '_').replace(/[^a-zA-Z0-9_]/g, '');

    if (!key) continue;

    sources[key] = {
      url: api.baseUrl + ep.path,
      page: '*',
      auth: ep.requiresAuth,
    };
  }

  return sources;
}
