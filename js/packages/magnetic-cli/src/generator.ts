// generator.ts — Auto-bridge generator
// Scans pages/ directory, detects state.ts, generates v8-bridge code
// so developers never write boilerplate wiring

import { readdirSync, readFileSync, statSync, existsSync } from 'node:fs';
import { join, relative, extname, basename, dirname } from 'node:path';

// ── Page scanning ───────────────────────────────────────────────────

export interface PageEntry {
  /** Relative path from app dir: "pages/TasksPage.tsx" */
  filePath: string;
  /** Import name: "TasksPage" */
  importName: string;
  /** Route path: "/" or "/about" or "*" */
  routePath: string;
  /** Whether this is the catch-all 404 page */
  isCatchAll: boolean;
}

export interface AppScan {
  pages: PageEntry[];
  /** Path to state module relative to app dir, or null */
  statePath: string | null;
  /** Whether state module exports toViewModel */
  hasViewModel: boolean;
  /** Path to magnetic-server package relative to app dir */
  serverPkgPath: string;
}

const PAGE_EXTENSIONS = ['.tsx', '.jsx', '.ts', '.js'];

const CATCH_ALL_NAMES = ['notfound', '404', 'notfoundpage', '_404', 'error'];
const INDEX_NAMES = ['index', 'indexpage', 'home', 'homepage', 'tasks', 'taskspage', 'main', 'mainpage'];

/**
 * Scan an app directory for pages and state.
 */
export function scanApp(appDir: string, monorepoRoot?: string): AppScan {
  const pagesDir = join(appDir, 'pages');
  const pages: PageEntry[] = [];

  if (existsSync(pagesDir)) {
    scanDir(pagesDir, '', pages);
  }

  // Detect state module
  const stateCandidates = [
    'state.ts', 'state.tsx',
    'server/state.ts', 'server/state.tsx',
    'store.ts', 'store.tsx',
  ];
  let statePath: string | null = null;
  let hasViewModel = false;

  for (const candidate of stateCandidates) {
    const full = join(appDir, candidate);
    if (existsSync(full)) {
      statePath = './' + candidate;
      // Check if it exports toViewModel (simple text search)
      const content = readFileSync(full, 'utf-8');
      hasViewModel = /export\s+(function|const)\s+toViewModel/.test(content);
      break;
    }
  }

  // Resolve path to @magneticjs/server
  let serverPkgPath: string;
  if (monorepoRoot) {
    const relPath = relative(appDir, join(monorepoRoot, 'js/packages/magnetic-server/src'));
    serverPkgPath = relPath.startsWith('.') ? relPath : './' + relPath;
  } else {
    serverPkgPath = '@magneticjs/server';
  }

  return { pages, statePath, hasViewModel, serverPkgPath };
}

function scanDir(dir: string, pathPrefix: string, pages: PageEntry[], rootPagesDir?: string) {
  const pagesRoot = rootPagesDir || dir;
  const entries = readdirSync(dir).sort();

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      // Nested directory → nested route
      let segment = entry;
      if (entry.startsWith('[') && entry.endsWith(']')) {
        segment = ':' + entry.slice(1, -1);
      }
      scanDir(fullPath, pathPrefix + '/' + segment, pages, pagesRoot);
      continue;
    }

    const ext = extname(entry);
    if (!PAGE_EXTENSIONS.includes(ext)) continue;

    // Skip special files
    const nameNoExt = basename(entry, ext);
    if (nameNoExt.startsWith('_') && !CATCH_ALL_NAMES.includes(nameNoExt.toLowerCase())) continue;
    if (nameNoExt === 'layout') continue;

    const importName = nameNoExt;
    const nameLower = nameNoExt.toLowerCase().replace(/page$/, '');

    let routePath: string;
    let isCatchAll = false;

    if (CATCH_ALL_NAMES.includes(nameLower)) {
      routePath = '*';
      isCatchAll = true;
    } else if (INDEX_NAMES.includes(nameLower)) {
      routePath = pathPrefix || '/';
    } else if (nameNoExt.startsWith('[') && nameNoExt.endsWith(']')) {
      // Dynamic param: [id].tsx → /:id
      const param = nameNoExt.slice(1, -1);
      routePath = pathPrefix + '/:' + param;
    } else {
      routePath = pathPrefix + '/' + nameLower;
    }

    // filePath relative to the app dir (e.g. "pages/AboutPage.tsx")
    const relFromPagesRoot = relative(pagesRoot, fullPath).replace(/\\/g, '/');
    const filePath = 'pages/' + relFromPagesRoot;

    pages.push({ filePath, importName, routePath, isCatchAll });
  }
}

// ── Bridge code generation ──────────────────────────────────────────

/**
 * Generate the v8-bridge.tsx source code from scan results.
 * This code is fed to esbuild (never written to disk as a permanent file).
 */
export function generateBridge(scan: AppScan): string {
  const lines: string[] = [];
  lines.push('// AUTO-GENERATED by @magnetic/cli — do not edit');
  lines.push(`import { createRouter } from '${scan.serverPkgPath}/router.ts';`);

  // Import pages
  const catchAllPage = scan.pages.find(p => p.isCatchAll);
  for (const page of scan.pages) {
    lines.push(`import { ${page.importName} } from './${page.filePath}';`);
  }

  // Import state (or generate default)
  if (scan.statePath) {
    lines.push(`import { initialState, reduce as _reduce${scan.hasViewModel ? ', toViewModel' : ''} } from '${scan.statePath}';`);
  } else {
    lines.push('');
    lines.push('// No state.ts found — using minimal default state');
    lines.push('function initialState() { return {}; }');
    lines.push('function _reduce(state, action, payload) { return state; }');
  }

  if (!scan.hasViewModel && scan.statePath) {
    lines.push('function toViewModel(s) { return s; }');
  } else if (!scan.statePath) {
    lines.push('function toViewModel(s) { return s; }');
  }

  // Router
  lines.push('');
  lines.push('const router = createRouter([');
  // Non-catch-all routes first
  for (const page of scan.pages) {
    if (!page.isCatchAll) {
      lines.push(`  { path: '${page.routePath}', page: ${page.importName} },`);
    }
  }
  // Catch-all last
  if (catchAllPage) {
    lines.push(`  { path: '*', page: ${catchAllPage.importName} },`);
  }
  lines.push(']);');

  // State + render/reduce
  lines.push('');
  lines.push('let state = initialState();');
  lines.push('');
  lines.push('export function render(path) {');
  lines.push('  const vm = toViewModel(state);');
  lines.push('  const result = router.resolve(path, vm);');
  if (catchAllPage) {
    lines.push(`  if (!result) return ${catchAllPage.importName}({ params: {} });`);
  } else {
    lines.push('  if (!result) return { tag: "div", text: "Not Found" };');
  }
  lines.push('  if (result.kind === \'redirect\') {');
  lines.push('    const r2 = router.resolve(result.to, vm);');
  lines.push('    if (r2 && r2.kind === \'render\') return r2.dom;');
  if (catchAllPage) {
    lines.push(`    return ${catchAllPage.importName}({ params: {} });`);
  } else {
    lines.push('    return { tag: "div", text: "Not Found" };');
  }
  lines.push('  }');
  lines.push('  return result.dom;');
  lines.push('}');
  lines.push('');
  lines.push('export function reduce(ap) {');
  lines.push('  const { action, payload = {}, path = \'/\' } = ap;');
  lines.push('  state = _reduce(state, action, payload);');
  lines.push('  return render(path);');
  lines.push('}');

  return lines.join('\n') + '\n';
}
