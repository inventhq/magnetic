use anyhow::{Context, Result};
use clap::Parser;
use serde_json::Value;
use std::{fs, path::PathBuf};

#[derive(Parser, Debug)]
#[command(name="magnetic-codegen", about="Emit typed stubs from contracts")]
struct Args {
    /// Path to contracts dir (e.g., contracts)
    contracts_dir: PathBuf,
    /// Output dir for generated files (e.g., tools/codegen/out)
    out_dir: PathBuf,
}

fn main() -> Result<()> {
    let args = Args::parse();
    fs::create_dir_all(&args.out_dir).ok();

    // load names
    let streams_path = args.contracts_dir.join(".well-known/streams.json");
    let actions_path = args.contracts_dir.join(".well-known/actions.json");
    let streams_v: Value =
        serde_json::from_str(&fs::read_to_string(&streams_path)?).context("streams.json parse")?;
    let actions_v: Value =
        serde_json::from_str(&fs::read_to_string(&actions_path)?).context("actions.json parse")?;

    let mut streams: Vec<String> = streams_v["streams"]
        .as_array()
        .unwrap_or(&vec![])
        .iter()
        .filter_map(|s| s.get("topic").and_then(|t| t.as_str()).map(|s| s.to_string()))
        .collect();

    let mut actions: Vec<String> = actions_v["actions"]
        .as_array()
        .unwrap_or(&vec![])
        .iter()
        .filter_map(|a| a.get("name").and_then(|t| t.as_str()).map(|s| s.to_string()))
        .collect();

    streams.sort();
    actions.sort();

    // TS
    let ts = render_ts(&streams, &actions);
    fs::write(args.out_dir.join("typed.ts"), ts)?;

    // Swift
    let swift = render_swift(&streams, &actions);
    fs::write(args.out_dir.join("Typed.swift"), swift)?;

    // Kotlin
    let kt = render_kotlin(&streams, &actions);
    fs::write(args.out_dir.join("Typed.kt"), kt)?;

    Ok(())
}

fn ident(s: &str) -> String {
    // simple, deterministic: non-alnum â†’ '_'
    s.chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect()
}

fn render_ts(streams: &[String], actions: &[String]) -> String {
    let mut out = String::new();
    out.push_str("// @generated by magnetic-codegen v0.1.0\n");
    out.push_str("// source: contracts/.well-known/{streams.json,actions.json}\n");
    out.push_str("export type StreamName =\n");
    for (i, s) in streams.iter().enumerate() {
        let bar = if i == 0 { "  |" } else { "  |" };
        out.push_str(&format!("{bar} \"{s}\"\n"));
    }
    out.push_str(";\n\nexport type ActionName =\n");
    for (i, a) in actions.iter().enumerate() {
        let bar = if i == 0 { "  |" } else { "  |" };
        out.push_str(&format!("{bar} \"{a}\"\n"));
    }
    out.push_str(";\n");
    out
}

fn render_swift(streams: &[String], actions: &[String]) -> String {
    let mut out = String::new();
    out.push_str("/*\n");
    out.push_str("// @generated by magnetic-codegen v0.1.0\n");
    out.push_str("// source: contracts/.well-known/{streams.json,actions.json}\n");
    out.push_str("*/\n");
    out.push_str("public enum StreamName: String {\n");
    for s in streams {
        out.push_str(&format!("    case {} = \"{}\"\n", ident(s), s));
    }
    out.push_str("}\n\npublic enum ActionName: String {\n");
    for a in actions {
        out.push_str(&format!("    case {} = \"{}\"\n", ident(a), a));
    }
    out.push_str("}\n");
    out
}

fn render_kotlin(streams: &[String], actions: &[String]) -> String {
    let mut out = String::new();
    out.push_str("/*\n");
    out.push_str("// @generated by magnetic-codegen v0.1.0\n");
    out.push_str("// source: contracts/.well-known/{streams.json,actions.json}\n");
    out.push_str("*/\n");
    out.push_str("enum class StreamName(val value: String) {\n");
    for (i, s) in streams.iter().enumerate() {
        let sep = if i + 1 == streams.len() { ";" } else { "," };
        out.push_str(&format!("    {}(\"{}\"){}\n", ident(s), s, sep));
    }
    out.push_str("}\n\nenum class ActionName(val value: String) {\n");
    for (i, a) in actions.iter().enumerate() {
        let sep = if i + 1 == actions.len() { ";" } else { "," };
        out.push_str(&format!("    {}(\"{}\"){}\n", ident(a), a, sep));
    }
    out.push_str("}\n");
    out
}
